type AssetData = record { balance : nat; name : text };
type CachedPrice = record { price : nat };
type Error = variant {
  NormalizedSupply;
  ConversionErrorToU128;
  NoDebtToRepay;
  FailedToReleaseLock;
  NoCanisterIdFound;
  ErrorBurnDebtTokens;
  SupplyCapExceeded;
  ErrorDecoding;
  InvalidAmount;
  BLOCKEDFORONEHOUR;
  ErrorInterestRate;
  AmountTooMuch;
  ErrorMintDebtTokens;
  NoUserReserveDataFound;
  ErrorGetBalance;
  LockAcquisitionFailed;
  ExchangeRateError;
  ErrorMintDTokens;
  ErrorFaucetTokens;
  InvalidAssetLength;
  InvalidCanister;
  LTVGreaterThanThreshold;
  ReserveInactive;
  InvalidVariableName;
  WithdrawMoreThanSupply;
  ErrorMintTokens;
  BorrowingNotEnabled;
  InvalidPrincipal;
  ErrorNotController;
  NoReserveDataFound;
  LowWalletBalance;
  USERCANNOTBELIQUIDATED;
  InvalidBurnAmount;
  AnonymousPrincipal;
  InvalidUserId;
  ErrorDTokenBalanceLessThan;
  EmailError;
  ErrorPriceCache;
  InvalidUser;
  EmptyAsset;
  TokenAlreadyExist;
  MaxAmount;
  ErrorParsingPrincipal;
  ReserveFrozen;
  LessRewardAmount;
  ErrorRollBack;
  AmountExceedsLimit;
  ErrorBurnDTokens;
  NoPriceCache;
  ConversionErrorFromTextToPrincipal;
  MaxAmountPlatform;
  NotFoundAssetPrincipal;
  LockOperationInProgess;
  ExceedsRemainingLimit;
  BorrowCapExceeded;
  InsufficientLiquidity;
  AmountSubtractionError;
  RewardIsHigher;
  ErrorEncoding;
  HealthFactorLess;
  UnauthorizedAccess;
  ReservePaused;
  ErrorBurnTokens;
  RepayMoreThanDebt;
  InvalidMintAmount;
  ErrorRawResponse;
  TOOMANYREQUESTS;
  UserNotFound;
  CalculateUserAccountDataError;
  NormalizedDebt;
};
type ExecuteBorrowParams = record { asset : text; amount : nat };
type ExecuteLiquidationParams = record {
  debt_asset : text;
  reward_amount : nat;
  collateral_asset : text;
  on_behalf_of : principal;
  amount : nat;
};
type ExecuteRepayParams = record {
  asset : text;
  on_behalf_of : opt principal;
  amount : nat;
};
type ExecuteSupplyParams = record {
  asset : text;
  is_collateral : bool;
  amount : nat;
};
type ExecuteWithdrawParams = record {
  asset : text;
  is_collateral : bool;
  on_behalf_of : opt principal;
  amount : nat;
};
type PriceCache = record { cache : vec record { text; CachedPrice } };
type ReserveConfiguration = record {
  ltv : nat;
  liquidation_protocol_fee : nat;
  active : bool;
  supply_cap : nat;
  borrow_cap : nat;
  reserve_factor : nat;
  borrowing_enabled : bool;
  frozen : bool;
  liquidation_bonus : nat;
  liquidation_threshold : nat;
  paused : bool;
};
type ReserveData = record {
  id : nat16;
  asset_name : opt text;
  asset_borrow : nat;
  can_be_collateral : opt bool;
  debt_token_canister : opt text;
  last_update_timestamp : nat64;
  liquidity_index : nat;
  d_token_canister : opt text;
  asset_supply : nat;
  current_liquidity_rate : nat;
  borrow_rate : nat;
  configuration : ReserveConfiguration;
  accure_to_platform : nat;
  debt_index : nat;
};
type Result = variant { Ok : text; Err : text };
type Result_1 = variant { Ok; Err : Error };
type Result_10 = variant { Ok : text; Err : Error };
type Result_2 = variant {
  Ok : record { nat; nat; nat; nat; nat; nat; bool };
  Err : Error;
};
type Result_3 = variant { Ok : UserData; Err : Error };
type Result_4 = variant { Ok : nat; Err : Error };
type Result_5 = variant { Ok : principal; Err : Error };
type Result_6 = variant { Ok : PriceCache; Err : Error };
type Result_7 = variant { Ok : record { nat; nat64 }; Err : Error };
type Result_8 = variant { Ok : bool; Err : Error };
type Result_9 = variant { Ok : ReserveData; Err : Error };
type UserAccountData = record {
  ltv : nat;
  available_borrow : nat;
  has_zero_ltv_collateral : bool;
  debt : nat;
  collateral : nat;
  health_factor : nat;
  liquidation_threshold : nat;
};
type UserData = record {
  reserves : opt vec record { text; UserReserveData };
  total_collateral : opt nat;
  total_debt : opt nat;
  user_id : opt text;
};
type UserReserveData = record {
  asset_borrow : nat;
  last_update_timestamp : nat64;
  d_token_balance : nat;
  is_collateral : bool;
  liquidity_index : nat;
  faucet_limit : nat;
  variable_borrow_index : nat;
  reserve : text;
  asset_supply : nat;
  faucet_usage : nat;
  debt_token_blance : nat;
  is_using_as_collateral_or_borrow : bool;
  is_borrowed : bool;
};
service : (principal) -> {
  add_controllers : (principal, principal) -> (Result);
  add_tester : (text, principal) -> (Result_1);
  calculate_user_asset_data : (
      opt principal,
      opt vec AssetData,
      opt vec AssetData,
    ) -> (Result_2) query;
  check_is_tester : () -> (bool) query;
  create_user_reserve_with_low_health : (text, text, nat, nat) -> (Result_3);
  cycle_checker : () -> (Result_4) query;
  execute_borrow : (ExecuteBorrowParams) -> (Result_4);
  execute_liquidation : (ExecuteLiquidationParams) -> (Result_4);
  execute_repay : (ExecuteRepayParams) -> (Result_4);
  execute_supply : (ExecuteSupplyParams) -> (Result_4);
  execute_withdraw : (ExecuteWithdrawParams) -> (Result_4);
  faucet : (text, nat) -> (Result_4);
  get_all_assets : () -> (vec text) query;
  get_all_users : () -> (vec record { principal; UserData }) query;
  get_asset_principal : (text) -> (Result_5) query;
  get_cached_exchange_rate : (text) -> (Result_6) query;
  get_exchange_rates : (text, opt text, nat) -> (Result_7);
  get_liquidation_users_concurrent : (nat64, nat64) -> (
      vec record { principal; UserAccountData; UserData },
    ) query;
  get_lock : () -> (Result_8) query;
  get_reserve_data : (text) -> (Result_9) query;
  get_total_supply : (principal) -> (Result_4) query;
  get_total_users : () -> (nat64) query;
  get_user_account_data : (
      opt principal,
      opt vec AssetData,
      opt vec AssetData,
    ) -> (Result_2) query;
  get_user_data : (principal) -> (Result_3) query;
  initialize : (text, ReserveData) -> (Result_1);
  queary_reserve_price : () -> (vec PriceCache) query;
  register_user : () -> (Result_10);
  reset_reserve_value : (text, text, nat) -> (Result_1);
  to_check_controller : () -> (bool) query;
  toggle_collateral : (text, nat, nat) -> (Result_1);
  unblock_user : (principal) -> (text);
  update_reserve_price_test : () -> (Result_1);
  update_reserves_price : () -> (Result_1);
  user_normalized_debt : (ReserveData) -> (Result_4) query;
  user_normalized_supply : (ReserveData) -> (Result_4) query;
}
